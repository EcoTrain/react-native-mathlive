import {GroupAtom} from '../core-atoms/group';
import {PlaceholderAtom} from '../core-atoms/placeholder';
import {ErrorAtom} from '../core-atoms/error';
import {TextAtom} from '../core-atoms/text';

import {Atom} from './atom';
import {tokenize} from './tokenizer';

function isLiteral(token) {
  return !/^<({|}|\$|\$\$|space)>$/.test(token);
}

/**
 * Transform a list of tokens into a list of atoms (a mathlist in TeX's parlance)
 *
 */
class Parser {
  // An array of tokens generated by the lexer
  tokens = [];

  // The current token to be parsed: index in `this.tokens`
  index = 0;

  // Accumulated errors encountered while parsing
  errors = [];

  // Optional arguments to substitute the `#` token.
  args;

  context;

  // Counter to prevent deadlock. If `end()` is called too many times (1,000)
  // in a row for the same token, bail.
  endCount = 0;

  /**
   * @param tokens - An array of tokens generated by the lexer.
   */
  constructor(tokens, context, options) {
    this.tokens = tokens;
    this.context = context;
    this.errors = [];
    this.args = options.args ?? null;
    this._currentParsingContext = {
      parent: undefined,
      // - the `mathlist` to examine the context of the command, modify atoms
      // in the current mathlist being constructed (e.g. `\limits`) or add
      // to the mathlist (when creating a new Atom)
      mathlist: [],
    };
  }

  get currentContext() {
    return this._currentParsingContext;
  }
  get rootContext() {
    let context = this._currentParsingContext;
    while (context.parent) {
      context = context.parent;
    }
    return context;
  }

  // Set new empty context for recursive parse child
  beginContext() {
    const newContext = {
      parent: this.currentContext,
      mathlist: [],
    };
    this._currentParsingContext = newContext;
  }

  // Set away parent context after parse child
  endContext() {
    this._currentParsingContext = this._currentParsingContext.parent;
  }

  onError(err) {
    this.errors.push({
      // before: tokensToString(this.tokens.slice(this.index, this.index + 10)),
      // after: tokensToString(this.tokens.slice(Math.max(0, this.index - 10), this.index)),
      ...err,
    });
  }

  get mathlist() {
    return this.currentContext.mathlist;
  }

  set mathlist(value) {
    this.currentContext.mathlist = value;
  }

  /**
   * True if we've reached the end of the token stream
   */
  isEnd() {
    // To prevent a deadlock, count how many times end() is called without the
    // index advancing. If it happens more than 1,000 times in a row,
    // assume something is broken and pretend the stream is finished.
    this.endCount++;
    return this.index >= this.tokens.length || this.endCount > 1000;
  }

  nextToken() {
    this.endCount = 0;
    return this.index < this.tokens.length ? this.tokens[this.index++] : '';
  }

  currentToken() {
    return this.tokens[this.index];
  }

  /**
   * @return True if the next token matches the input, and advance
   */
  match(input) {
    if (this.tokens[this.index] === input) {
      this.index++;
      return true;
    }
    return false;
  }

  /**
   * Return the appropriate value for a placeholder, either a default
   * one, or if a value was provided for #? via args, that value.
   */
  placeholder() {
    const placeHolderArg = this.args?.('?');
    if (!placeHolderArg) {
      return [new PlaceholderAtom(this.context, {})];
    }

    // If there is a specific value defined for the placeholder,
    // use it.
    return parseLatex(placeHolderArg, this.context, {});
  }

  matchWhitespace() {
    let found = false;
    while (this.match('<space>')) {
      found = true;
    }
    return found;
  }

  skipUntilToken(input) {
    let token = this.tokens[this.index];
    while (token && token !== input) {
      token = this.tokens[++this.index];
    }

    if (token === input) {
      this.index++;
    }
  }

  skipFiller() {
    let done = false;
    do {
      const skippedSpace = this.matchWhitespace();
      done = !skippedSpace;
    } while (!done);
  }

  /**
   * Keywords are used to specify dimensions, and for various other
   * syntactic constructs.
   *
   * Unlike commands, they are not case sensitive.
   *
   * There are 25 keywords:
   *
   * at by bp cc cm dd depth em ex fil fill filll height in minus
   * mm mu pc plus pt sp spread to true width
   *
   * TeX: 8212
   * @return true if the expected keyword is present
   */
  matchKeyword(keyword) {
    const savedIndex = this.index;
    let done = this.isEnd();
    let value = '';
    while (!done) {
      const token = this.nextToken();
      if (isLiteral(token)) {
        value += token;
        done = this.isEnd() || value.length >= keyword.length;
      } else {
        done = true;
      }
    }

    const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
    if (!hasKeyword) {
      this.index = savedIndex;
    }

    return hasKeyword;
  }

  /**
   * Return a sequence of characters as a string.
   * i.e. 'abcd' returns 'abcd'.
   * Terminates on the first non-literal token encountered
   * e.g. '<{>', '<}>' etc...
   * Will also terminate on character literal ']'
   */
  scanString() {
    let result = '';
    while (!this.isEnd()) {
      if (this.match('<space>')) {
        result += ' ';
      } else {
        const token = this.currentToken();

        if (token === ']') {
          break;
        }

        if (isLiteral(token)) {
          result += this.nextToken();
        } else if (token.startsWith('\\')) {
          // TeX will give a 'Missing \endcsname inserted' error
          // if it encounters any command when expecting a string.
          // We're a bit more lax.
          this.onError({code: 'unbalanced-braces'});
          result += this.nextToken();
        } else {
          // It's '<{>', '<}>', '<$>' or '<$$>
          break;
        }
      }
    }

    return result;
  }

  /**
   * Parse a sequence until a group end marker, such as
   * `}`, `\end`, `&`, etc...
   *
   * Returns an array of atoms or an empty array if the sequence
   * terminates right away.
   *
   * @param done - A predicate indicating if a
   * token signals the end of an implicit group
   */
  parse(done) {
    // Set new context
    this.beginContext();

    // Default group end marker
    if (!done) {
      done = token => token === '<}>';
    }

    const saveAtoms = this.mathlist;
    this.mathlist = [];
    while (!this.isEnd() && !done(this.currentToken())) {
      this.parseToken();
    }
    let result = this.mathlist;
    this.mathlist = saveAtoms;

    // Return away prev context after parse token child
    this.endContext();

    return result;
  }

  /**
   * Make an atom for the current token or token group and
   * add it to the parser's mathlist
   */
  parseToken() {
    let result = this.parseGroup();
    if (result === null) {
      result = this.parseSimpleToken();
    }

    // If we have an atom to add, push it at the end of the current math list
    if (Array.isArray(result)) {
      this.mathlist.push(...result);
    } else if (result) {
      this.mathlist.push(result);
    }

    return result !== null;
  }

  /**
   * Parse a group enclosed in a pair of braces: `{...}`.
   *
   * Return either a group Atom or null if not a group.
   *
   * Return a group Atom with an empty body if an empty
   * group (i.e. `{}`).
   */
  parseGroup() {
    if (!this.match('<{>')) {
      return null;
    }
    const result = new GroupAtom(
      this.parse(token => token === '<}>'),
      this.context,
      {
        latexOpen: '{',
        latexClose: '}',
      }
    );

    if (!this.match('<}>')) {
      this.onError({code: 'unbalanced-braces'});
    }

    return result;
  }

  parseSimpleToken() {
    const token = this.nextToken();
    if (!token) {
      return null;
    }
    if (token === '<space>') {
      return [new TextAtom(' ', ' ', this.context)];
    }

    if (token.startsWith('\\')) {
      return this.parseCommand(token);
    }
    if (isLiteral(token)) {
      return this.parseLiteral(token);
    }
    if (token === '<}>') {
      this.onError({latex: '', code: 'unbalanced-braces'});
    } else {
      this.onError({
        latex: '',
        code: 'unexpected-token',
        arg: token,
      });
    }

    return null;
  }

  parseCommand(command) {
    if (command === '\\placeholder') {
      return [
        new PlaceholderAtom(this.context, {
          value: this.parseArgument('string') ?? undefined,
        }),
      ];
    }

    let result = null;

    const info = this.context.getDefinition(command);

    if (!info) {
      // An unknown command
      this.onError({code: 'unknown-command', arg: command});
      return [new ErrorAtom(command, this.context)];
    }

    if (info.definitionType === 'symbol') {
      result = new Atom(info.type ?? 'mop', this.context, {
        command,
        value: info.symbol,
      });
    } else {
      const [deferredArg, args] = this.parseArguments(info);

      if (!args) {
        return null;
      } // Some required arguments were missing...

      //  Invoke the createAtom() function if present
      if (typeof info.createAtom === 'function') {
        result = info.createAtom(command, args, this.context);
        if (deferredArg) {
          result.body = this.parseArgument(deferredArg) ?? undefined;
        }
      } else {
        result = new Atom('mop', this.context, {
          command: info.command ?? command,
          value: command,
        });
      }
    }

    return result ? [result] : null;
  }

  parseArguments(info) {
    if (!info || !info.params) {
      return [undefined, []];
    }
    let explicitGroup;
    const args = [];
    let i = 0;

    while (i < info.params.length) {
      const parameter = info.params[i];
      // Parse an argument
      if (parameter.isOptional) {
        args.push(this.parseOptionalArgument(parameter.type));
      } else {
        const arg = this.parseArgument(parameter.type);
        if (arg !== null) {
          args.push(arg);
        } else {
          // Report an error
          this.onError({code: 'missing-argument'});
          switch (parameter.type) {
            case 'string':
              args.push('');
              break;
            case 'auto':
            default:
              args.push(this.placeholder());
              break;
          }
        }
      }
      i += 1;
    }
    return [explicitGroup, args];
  }

  /**
   * Parse a math field (in the TeX parlance), an argument to a function.
   *
   * An argument can either be a single atom or  a sequence of atoms enclosed
   * in braces.
   *
   */
  parseArgument(argType) {
    this.skipFiller();
    if (argType === 'auto') {
      argType = 'math';
    }
    let result = null;

    // An argument (which is called a 'math field' in TeX)
    // could be a single character or symbol, as in `\frac12`
    // Note that ``\frac\sqrt{-1}\alpha\beta`` is equivalent to
    // ``\frac{\sqrt}{-1}{\beta}``
    const hasBrace = this.currentToken() === '<{>';
    if (!hasBrace) {
      if (argType === 'text' || argType === 'math') {
        // Parse a single token.
        this.beginContext();
        const atom = this.parseSimpleToken();
        this.endContext();
        return atom;
      }
    }

    if (hasBrace) {
      this.nextToken();
    }

    if (argType === 'text' || argType === 'math') {
      this.beginContext({mode: argType});
      do {
        this.mathlist.push(...this.parse());
      } while (!this.match('<}>') && !this.isEnd());
    } else {
      this.beginContext();
      if (argType === 'string') {
        result = this.scanString();
      }

      if (hasBrace) {
        this.skipUntilToken('<}>');
      }

      if (result === null) {
        this.endContext();
        return null;
      }
    }
    const atoms = this.mathlist;
    this.endContext();
    return result ?? atoms;
  }
  parseOptionalArgument(argType) {
    this.matchWhitespace();
    if (!this.match('[')) {
      return null;
    }
    let result = null;
    while (!this.isEnd() && !this.match(']')) {
      if (argType === 'string') {
        result = this.scanString();
      } else if (argType === 'math') {
        this.beginContext({mode: 'math'});
        result = this.mathlist.concat(this.parse(token => token === ']'));
        this.endContext();
      }
    }

    return result;
  }
  parseLiteral(literal) {
    const atom = new TextAtom(literal, literal, this.context);
    return atom;
  }
}

/**
 * Given a string of LaTeX, return a corresponding array of atoms.
 * @param args - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 */
export function parseLatex(s, context, options) {
  // const validateErrors = validateLatex(s, context);
  // console.log({validateErrors});

  const args = options?.args ?? null;
  const tokens = tokenize(s, args);
  const parser = new Parser(tokens, context, {
    args,
  });

  const atoms = [];
  while (!parser.isEnd()) {
    atoms.push(...parser.parse());
  }
  // console.log('Parse latex result', {tokens, atoms, context});
  return atoms;
}

export function validateLatex(s, context) {
  const parser = new Parser(tokenize(s, null), context, {
    args: null,
  });

  while (!parser.isEnd()) {
    parser.parse();
  }
  return parser.errors;
}
