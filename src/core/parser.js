import {GroupAtom} from '../core-atoms/group';
import {PlaceholderAtom} from '../core-atoms/placeholder';
import {ErrorAtom} from '../core-atoms/error';
import {TextAtom} from '../core-atoms/text';

import {Atom} from './atom';
import {Mode} from './modes';
import {tokenize} from './tokenizer';

// Performance to check first char of string: https://jsben.ch/QLjdZ

function isLiteral(token) {
  return !/^<({|}|\$|\$\$|space)>$/.test(token);
}

/**
 * Transform a list of tokens into a list of atoms (a mathlist in TeX's parlance)
 *
 */
class Parser {
  // An array of tokens generated by the lexer
  tokens;

  // The current token to be parsed: index in `this.tokens`
  index = 0;

  // Accumulated errors encountered while parsing
  errors;

  // Optional arguments to substitute the `#` token.
  args;

  // Counter to prevent deadlock. If `end()` is called too many times (1,000)
  // in a row for the same token, bail.
  endCount = 0;

  _currentParsingContext;

  context;

  /**
   * @param tokens - An array of tokens generated by the lexer.
   */
  constructor(tokens, context, options) {
    this.tokens = tokens;
    this.context = context;

    this.errors = [];
    this.args = options.args ?? null;
    this._currentParsingContext = {
      parent: undefined,
      mathlist: [],
      parseMode: 'math',
      mathstyle: 'displaystyle',
      tabular: false,
    };
  }

  get currentContext() {
    return this._currentParsingContext;
  }
  get rootContext() {
    let context = this._currentParsingContext;
    while (context.parent) context = context.parent;
    return context;
  }

  beginContext(options) {
    const newContext = {
      parent: this.currentContext,
      mathlist: [],
      parseMode: options?.mode ?? this.currentContext.parseMode,
      mathstyle: options?.mathstyle ?? this.currentContext.mathstyle,
      tabular: options?.tabular ?? false,
    };
    this._currentParsingContext = newContext;
  }

  endContext() {
    this._currentParsingContext = this._currentParsingContext.parent;
  }

  onError(err) {
    this.errors.push({
      ...err,
    });
  }

  get mathlist() {
    return this.currentContext.mathlist;
  }

  set mathlist(value) {
    this.currentContext.mathlist = value;
  }

  get parseMode() {
    return this.currentContext.parseMode;
  }

  // @revisit
  set parseMode(value) {
    this.currentContext.parseMode = value;
  }

  get tabularMode() {
    return this.currentContext.tabular;
  }

  /**
   * True if we've reached the end of the token stream
   */
  end() {
    // To prevent a deadlock, count how many times end() is called without the
    // index advancing. If it happens more than 1,000 times in a row,
    // assume something is broken and pretend the stream is finished.
    this.endCount++;
    return this.index >= this.tokens.length || this.endCount > 1000;
  }

  get() {
    this.endCount = 0;
    return this.index < this.tokens.length ? this.tokens[this.index++] : '';
  }

  currentToken() {
    return this.tokens[this.index];
  }

  /**
   * @return True if the next token matches the input, and advance
   */
  match(input) {
    if (this.tokens[this.index] === input) {
      this.index++;
      return true;
    }

    return false;
  }

  /**
   * @return True if the next token matches the specified regular expression pattern.
   */
  hasPattern(pattern) {
    return pattern.test(this.tokens[this.index]);
  }

  // Проверка на вложенные команды
  hasInfixCommand() {
    const {index} = this;
    if (index < this.tokens.length && this.tokens[index].startsWith('\\')) {
      const info = this.context.getDefinition(this.tokens[index], this.parseMode);
      if (!info || info.definitionType === 'symbol') return false;
      if (info.ifMode && !info.ifMode.includes(this.parseMode)) return false;

      return info.infix ?? false;
    }

    return false;
  }

  /**
   * Return the appropriate value for a placeholder, either a default
   * one, or if a value was provided for #? via args, that value.
   */
  placeholder() {
    const placeHolderArg = this.args?.('?');
    if (!placeHolderArg) {
      return [
        new PlaceholderAtom(this.context, {
          mode: this.parseMode,
        }),
      ];
    }

    // If there is a specific value defined for the placeholder,
    // use it.
    return parseLatex(placeHolderArg, this.context, {
      parseMode: this.parseMode,
      mathstyle: 'textstyle',
    });
  }

  matchWhitespace() {
    let found = false;
    while (this.match('<space>')) found = true;

    return found;
  }

  skipUntilToken(input) {
    let token = this.tokens[this.index];
    while (token && token !== input) token = this.tokens[++this.index];

    if (token === input) this.index++;
  }

  skipFiller() {
    let done = false;
    do {
      const skippedSpace = this.matchWhitespace();
      const skippedRelax = this.match('\\relax');
      done = !skippedSpace && !skippedRelax;
    } while (!done);
  }

  /**
   * Keywords are used to specify dimensions, and for various other
   * syntactic constructs.
   *
   * Unlike commands, they are not case sensitive.
   *
   * There are 25 keywords:
   *
   * at by bp cc cm dd depth em ex fil fill filll height in minus
   * mm mu pc plus pt sp spread to true width
   *
   * TeX: 8212
   * @return true if the expected keyword is present
   */
  matchKeyword(keyword) {
    const savedIndex = this.index;
    let done = this.end();
    let value = '';
    while (!done) {
      const token = this.get();
      if (isLiteral(token)) {
        value += token;
        done = this.end() || value.length >= keyword.length;
      } else done = true;
    }

    const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
    if (!hasKeyword) this.index = savedIndex;

    return hasKeyword;
  }

  /**
   * Return a sequence of characters as a string.
   * i.e. 'abcd' returns 'abcd'.
   * Terminates on the first non-literal token encountered
   * e.g. '<{>', '<}>' etc...
   * Will also terminate on character literal ']'
   */
  scanString() {
    let result = '';
    while (!this.end()) {
      if (this.match('<space>')) result += ' ';
      else {
        const token = this.currentToken();

        if (token === ']') break;

        if (isLiteral(token)) result += this.get();
        else if (token.startsWith('\\')) {
          // TeX will give a 'Missing \endcsname inserted' error
          // if it encounters any command when expecting a string.
          // We're a bit more lax.
          this.onError({code: 'unbalanced-braces'});
          result += this.get();
        } else {
          // It's '<{>', '<}>', '<$>' or '<$$>
          break;
        }
      }
    }

    return result;
  }

  /**
   * Return as a number a group of characters representing a
   * numerical quantity.
   *
   * From TeX:8695 (scan_int):
   * > An integer number can be preceded by any number of spaces and `+' or
   * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
   * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
   * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
   * > an internal variable.
   */
  scanNumber(isInteger = true) {
    let negative = false;
    let token = this.currentToken();
    while (token === '<space>' || token === '+' || token === '-') {
      this.get();
      if (token === '-') negative = !negative;
      token = this.currentToken();
    }

    isInteger = Boolean(isInteger);

    let radix = 10;
    let digits = /\d/;

    if (this.match("'")) {
      // Apostrophe indicates an octal value
      radix = 8;
      digits = /[0-7]/;
      isInteger = true;
    } else if (this.match('"') || this.match('x')) {
      // Double-quote indicates a hex value
      // The 'x' prefix notation for the hexadecimal numbers is a MathJax extension.
      // For example: 'x3a'
      radix = 16;
      // Hex digits have to be upper-case
      digits = /[\dA-F]/;
      isInteger = true;
    } else if (this.match('`')) {
      // A backtick indicates an alphabetic constant: a letter, or a single-letter command
      token = this.get();
      if (token) {
        if (token.startsWith('\\') && token.length === 2) return (negative ? -1 : 1) * (token.codePointAt(1) ?? 0);

        return (negative ? -1 : 1) * (token.codePointAt(0) ?? 0);
      }

      return null;
    }

    let value = '';
    while (this.hasPattern(digits)) value += this.get();

    // Parse the fractional part, if applicable
    // Note: TeX does accept `,` as a decimal separator see TeX: `continental_point_token`
    if (!isInteger && (this.match('.') || this.match(','))) {
      value += '.';
      while (this.hasPattern(digits)) value += this.get();
    }

    const result = isInteger ? Number.parseInt(value, radix) : Number.parseFloat(value);
    if (Number.isNaN(result)) return null;
    return negative ? -result : result;
  }

  /**
   * Parse a sequence until a group end marker, such as
   * `}`, `\end`, `&`, etc...
   *
   * Returns an array of atoms or an empty array if the sequence
   * terminates right away.
   *
   * @param done - A predicate indicating if a
   * token signals the end of an implicit group
   */
  parse(done) {
    this.beginContext();

    // Default group end marker
    if (!done) done = token => token === '<}>';

    // To handle infix commands, we'll keep track of their prefix
    // (tokens coming before them) and their arguments
    let infix = '';
    let infixInfo = null;
    let infixArgs = [];
    let prefix = null;
    const saveAtoms = this.mathlist;
    this.mathlist = [];

    while (!this.end() && !done(this.currentToken())) {
      // Проверка на вложенные команды
      if (this.hasInfixCommand() && !infix) {
        // Следующий токен — это инфикс, и мы его еще не видели
        // (может быть только одна инфиксная команда на неявную группу).
        infix = this.get();
        // The current parseMode, this.parseMode, may no longer have the value
        // it had when we encountered the infix. However, since all infix are
        // only defined in 'math' mode, we can use the 'math' constant
        // for the parseMode
        infixInfo = this.context.getDefinition(infix, 'math');
        if (infixInfo) infixArgs = this.parseArguments(infixInfo)[1];

        // Save the math list so far and start a new one
        prefix = this.mathlist;
        this.mathlist = [];
      } else this.parseToken();
    }

    let result;
    if (infix) {
      infixArgs.unshift(this.mathlist); // Suffix
      this.mathlist = saveAtoms;
      if (prefix) infixArgs.unshift(prefix);
      result = [infixInfo.createAtom(infix, infixArgs, this.context)];
    } else {
      result = this.mathlist;
      this.mathlist = saveAtoms;
    }

    this.endContext();

    return result;
  }

  /**
   * Parse a group enclosed in a pair of braces: `{...}`.
   *
   * Return either a group Atom or null if not a group.
   *
   * Return a group Atom with an empty body if an empty
   * group (i.e. `{}`).
   */
  parseGroup() {
    if (!this.match('<{>')) return null;
    const result = new GroupAtom(
      this.parse(token => token === '<}>'),
      this.context,
      {
        mode: this.parseMode,
        latexOpen: '{',
        latexClose: '}',
      }
    );

    if (!this.match('<}>')) this.onError({code: 'unbalanced-braces'});

    return result;
  }

  /**
   * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
   *
   * @return The delimiter (as a character or command) or null
   */
  scanDelim() {
    this.matchWhitespace();
    const token = this.get();
    if (!token) {
      this.onError({code: 'unexpected-end-of-string'});
      return null;
    }

    let delim = '.';
    if (token.startsWith('\\') || isLiteral(token)) delim = token;

    const info = this.context.getDefinition(delim, 'math');
    if (!info) {
      this.onError({code: 'unknown-command', arg: delim});
      return null;
    }

    if (info.definitionType === 'function' && info.ifMode && !info.ifMode.includes(this.parseMode)) {
      this.onError({code: 'unexpected-delimiter', arg: delim});
      return null;
    }

    if (info.definitionType === 'symbol' && (info.type === 'mopen' || info.type === 'mclose')) return delim;

    // Some symbols are not of type mopen/mclose, but are still
    // valid delimiters...
    // '?' is a special delimiter used as a 'placeholder'
    // (when the closing delimiter is displayed greyed out)
    if (
      /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
        delim
      )
    )
      return delim;

    this.onError({code: 'unexpected-delimiter', arg: delim});
    return null;
  }

  parseArguments(info) {
    if (!info || !info.params) return [undefined, []];
    let explicitGroup = undefined;
    const args = [];
    let i = info.infix ? 2 : 0;
    while (i < info.params.length) {
      const parameter = info.params[i];
      // Parse an argument
      if (parameter?.type === 'rest') {
        args.push(
          this.parse(
            token => token === '<}>' || token === '&' || token === '\\end' || token === '\\cr' || token === '\\\\'
          )
        );
      } else if (parameter.isOptional) args.push(this.parseOptionalArgument(parameter.type));
      else if (parameter.type.endsWith('*')) {
        // For example 'math*'.
        // In this case, indicate that a 'yet-to-be-parsed'
        // argument (and 'explicit group') is present
        explicitGroup = parameter?.type.slice(0, -1);
      } else {
        const arg = this.parseArgument(parameter.type);
        console.log({arg, parameter});
        if (arg !== null) args.push(arg);
        else {
          // Report an error
          this.onError({code: 'missing-argument'});
          switch (parameter.type) {
            case 'number':
              // case 'dimen':
              // case 'glue':
              args.push(0);
              break;
            case 'dimen':
              args.push({dimension: 0, unit: 'pt'});
              break;
            case 'glue':
              args.push({glue: {dimension: 0, unit: 'pt'}});
              break;
            case 'string':
            case 'balanced-string':
              args.push('');
              break;
            case 'delim':
              args.push('.');
              break;
            case 'colspec':
              args.push('llllllllll');
              break;
            case 'auto':
            default:
              args.push(this.placeholder());
              break;
          }
        }
      }

      i += 1;
    }

    return [explicitGroup, args];
  }

  /**
   * Parse a math field (in the TeX parlance), an argument to a function.
   *
   * An argument can either be a single atom or  a sequence of atoms enclosed
   * in braces.
   *
   */
  parseArgument(argType) {
    this.skipFiller();
    if (argType === 'auto') argType = this.parseMode;
    let result = null;

    // An argument (which is called a 'math field' in TeX)
    // could be a single character or symbol, as in `\frac12`
    // Note that ``\frac\sqrt{-1}\alpha\beta`` is equivalent to
    // ``\frac{\sqrt}{-1}{\beta}``
    const hasBrace = this.currentToken() === '<{>';
    if (!hasBrace) {
      if (argType === 'delim') return this.scanDelim() ?? '.';

      if (argType === 'text' || argType === 'math') {
        // Parse a single token.
        this.beginContext();
        const atom = this.parseSimpleToken();
        this.endContext();
        return atom;
      }
    }

    if (hasBrace) this.get();

    if (argType === 'text' || argType === 'math') {
      this.beginContext({mode: argType});
      do this.mathlist.push(...this.parse());
      while (!this.match('<}>') && !this.end());
    } else {
      this.beginContext();
      if (argType === 'string') result = this.scanString();
      else if (argType === 'balanced-string') result = this.scanBalancedString();
      else if (argType === 'number') result = this.scanNumber();
      else if (argType === 'colspec') result = this.scanColspec();
      else if (argType === 'dimen') result = this.scanDimen();
      else if (argType === 'glue') result = this.scanGlue();
      else if (argType === 'delim') result = this.scanDelim() ?? '.';

      if (hasBrace) this.skipUntilToken('<}>');

      if (result === null) {
        this.endContext();
        return null;
      }
    }

    const atoms = this.mathlist;
    this.endContext();
    return result ?? atoms;
  }

  parseOptionalArgument(argType) {
    argType = argType === 'auto' ? this.parseMode : argType;
    this.matchWhitespace();
    if (!this.match('[')) return null;
    let result = null;
    while (!this.end() && !this.match(']')) {
      if (argType === 'string') result = this.scanString();
      else if (argType === 'number') result = this.scanNumber();
      else if (argType === 'math') {
        this.beginContext({mode: 'math'});
        result = this.mathlist.concat(this.parse(token => token === ']'));
        this.endContext();
      }
    }

    return result;
  }

  parseCommand(command) {
    if (command === '\\placeholder') {
      return [
        new PlaceholderAtom(this.context, {
          mode: this.parseMode,
          placeholderId: this.parseOptionalArgument('string'),
          value: this.parseArgument('string') ?? undefined,
        }),
      ];
    }

    let result = null;

    const info = this.context.getDefinition(command, this.parseMode);

    if (!info) {
      // An unknown command
      this.onError({code: 'unknown-command', arg: command});
      return [new ErrorAtom(command, this.context)];
    }

    if (info.definitionType === 'symbol') {
      result = new Atom(info.type ?? 'mop', this.context, {
        command,
        value: String.fromCodePoint(info.codepoint),
        mode: this.parseMode,
      });
    } else {
      if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
        // Command not applicable in this mode: ignore it (TeX behavior)
        // (for example `\Huge` in math mode
        return [];
      }

      // Parse the arguments.
      //
      // If `deferredArg` is not empty, the content after the command
      // will be parsed *after* the command has been initially processed
      // (atom creation or style application) and passed to
      //
      // In definitions, this is indicated with a parameter type
      // thats ends with a '*' ('math*', 'auto*').

      const savedMode = this.parseMode;
      if (info.applyMode) this.parseMode = info.applyMode;

      const [deferredArg, args] = this.parseArguments(info);
      this.parseMode = savedMode;

      if (!args) return null; // Some required arguments were missing...

      if (info.infix) {
        // Infix commands should be handled in scanImplicitGroup
        // If we find an infix command here, it's a syntax error
        // (second infix command in a group) and should be ignored.
        this.onError({
          code: 'too-many-infix-commands',
          arg: command,
        });
        return null;
      }

      //  Invoke the createAtom() function if present
      if (typeof info.createAtom === 'function') {
        result = info.createAtom(command, args, this.context);
        if (deferredArg) result.body = this.parseArgument(deferredArg) ?? undefined;
      } else {
        result = new Atom('mop', this.context, {
          command: info.command ?? command,
          value: command,
          mode: info.applyMode ?? this.parseMode,
        });
      }
    }

    return result ? [result] : null;
  }

  parseLiteral(literal) {
    const result = Mode.createAtom(this.parseMode, literal, this.context);
    if (!result) return null;

    return [result];
  }

  parseSimpleToken() {
    const token = this.get();
    if (!token) return null;
    if (token === '<space>') {
      if (this.parseMode === 'text') return [new TextAtom(' ', ' ', this.context)];
      return null;
    }

    if (token.startsWith('\\')) return this.parseCommand(token);
    if (isLiteral(token)) return this.parseLiteral(token);
    if (token === '<}>') this.onError({latex: '', code: 'unbalanced-braces'});
    else {
      this.onError({
        latex: '',
        code: 'unexpected-token',
        arg: token,
      });
    }

    return null;
  }

  /**
   * Make an atom for the current token or token group and
   * add it to the parser's mathlist
   */
  parseToken() {
    let result = this.parseGroup();
    if (result === null) {
      result = this.parseSimpleToken();
    }
    // If we have an atom to add, push it at the end of the current math list
    // We could have no atom for tokens that were skipped, a ' ' in math mode
    // for example
    if (Array.isArray(result)) this.mathlist.push(...result);
    else if (result) this.mathlist.push(result);

    return result !== null;
  }
}

/**
 * Given a string of LaTeX, return a corresponding array of atoms.
 * @param args - If there are any placeholder tokens, e.g.
 * `#0`, `#1`, etc... they will be replaced by the value provided by `args`.
 */
export function parseLatex(s, context, options) {
  const args = options?.args ?? null;
  const parser = new Parser(tokenize(s, args), context, {
    args,
    mathstyle: 'displaystyle',
    parseMode: options?.parseMode ?? 'math',
  });

  const atoms = [];
  while (!parser.end()) atoms.push(...parser.parse());
  return atoms;
}

export function validateLatex(s, context, options) {
  const parser = new Parser(tokenize(s, null), context, {
    args: null,
    mathstyle: 'displaystyle',
    parseMode: options?.parseMode ?? 'math',
  });

  while (!parser.end()) parser.parse();
  return parser.errors;
}
